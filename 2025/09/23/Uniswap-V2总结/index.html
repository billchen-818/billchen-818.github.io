<!DOCTYPE html><html lang="zh-cn"><head><title>Uniswap V2总结</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><h1>Uniswap V2总结</h1><div class="time">2025-09-23</div><ul class="tags"><li><span>#</span><a href="/tags/Defi/">Defi</a></li></ul><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Uniswap V2是最基本的恒定乘积做市商去中心化dex应用，它的核心就是<code>x*y=k</code>。它主要有以下几个功能：</p>
<ul>
<li>添加流动性</li>
<li>移除流动性</li>
<li>swap交易</li>
<li>可以提供价格预言机</li>
<li>可以闪电贷</li>
</ul>
<p>其中上面三个是最主要，最基本的功能。</p>
<p>它代码主要有两个仓库：<code>uniswap-v2-core</code>和<code>v2-periphery</code>。</p>
<h2 id="添加流动性"><a href="#添加流动性" class="headerlink" title="添加流动性"></a>添加流动性</h2><p>每一个交易对都是一个Pair合约。Pair合约中有四个主要的状态变量，token0、token1、reserve0、reserve1，分别是token0的地址、token1的地址、当前池子中token0的代币量、当前池子中token1的代币量。</p>
<p>添加流动性主要是用户向池子中转账两个代币，根据转入的数量去mint凭证。</p>
<pre><code class="highlight solidity">function mint(address to) external lock returns (uint liquidity) &#123;
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    uint balance0 = IERC20(token0).balanceOf(address(this));
    uint balance1 = IERC20(token1).balanceOf(address(this));
    uint amount0 = balance0.sub(_reserve0);
    uint amount1 = balance1.sub(_reserve1);

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    if (_totalSupply == 0) &#123;
        liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
       _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
    &#125; else &#123;
        liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
    &#125;
    require(liquidity &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&#x27;);
    _mint(to, liquidity);

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Mint(msg.sender, amount0, amount1);
&#125;</code></pre>

<p>上面是mint的函数：</p>
<ul>
<li>如果是第一次添加流动性，会先mint 1000个流动性凭证给零地址，然后在计算流动性值，流动性值就是转入的两种代币熟练乘积开平方在减去1000，最后就是给to地址mint 流动性凭证，并更新池子中的reserve0、reserve1。</li>
<li>非第一次添加流动性，按照比例来添加流动性，新增流动性&#x2F;总的流动性&#x3D;新增资产&#x2F;总资产，这里要对两种资产中都计算，取小的值，为了保护原有流动性的提供者。同样的，下面就是给to地址mint 流动性凭证，并更新池子中的reserve0、reserve1。</li>
</ul>
<h2 id="移除流动性"><a href="#移除流动性" class="headerlink" title="移除流动性"></a>移除流动性</h2><p>移除流动性就是销毁LP-Token，取回自己添加的资金。</p>
<pre><code class="highlight solidity">function removeLiquidity(
    address tokenA,
    address tokenB,
    uint liquidity,
    uint amountAMin,
    uint amountBMin,
    address to,
    uint deadline
) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;
    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);
    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
    require(amountA &gt;= amountAMin, &#x27;UniswapV2Router: INSUFFICIENT_A_AMOUNT&#x27;);
    require(amountB &gt;= amountBMin, &#x27;UniswapV2Router: INSUFFICIENT_B_AMOUNT&#x27;);
&#125;</code></pre>

<p>在<code>removeLiquidity</code>函数中把流动性<code>liquidity</code>发送给pair合约。</p>
<pre><code class="highlight solidity">function burn(address to) external lock returns (uint amount0, uint amount1) &#123;
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    address _token0 = token0;                                // gas savings
    address _token1 = token1;                                // gas savings
    uint balance0 = IERC20(_token0).balanceOf(address(this));
    uint balance1 = IERC20(_token1).balanceOf(address(this));
    uint liquidity = balanceOf[address(this)];

    bool feeOn = _mintFee(_reserve0, _reserve1);
    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
    require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;);
    _burn(address(this), liquidity);
    _safeTransfer(_token0, to, amount0);
    _safeTransfer(_token1, to, amount1);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));

    _update(balance0, balance1, _reserve0, _reserve1);
    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
    emit Burn(msg.sender, amount0, amount1, to);
&#125;</code></pre>

<p>在<code>burn</code>函数中，</p>
<ul>
<li>首先获取两种代币的余额，其次获取流动性；</li>
<li>其次会计算出取回的两种代币的数目；</li>
<li>然后会把流动性销毁掉，再把要取回的代币转移到目的地址<code>to</code>；</li>
<li>最后会更新合约的储备reserve0和reserve1；</li>
</ul>
<h2 id="swap功能"><a href="#swap功能" class="headerlink" title="swap功能"></a>swap功能</h2><pre><code class="highlight solidity">function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;
    for (uint i; i &lt; path.length - 1; i++) &#123;
        (address input, address output) = (path[i], path[i + 1]);
        (address token0,) = UniswapV2Library.sortTokens(input, output);
        uint amountOut = amounts[i + 1];
        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));
        address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
        IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
            amount0Out, amount1Out, to, new bytes(0)
        );
    &#125;
&#125;</code></pre>

<pre><code class="highlight solidity">function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;
    require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;);

    uint balance0;
    uint balance1;
    &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors
    address _token0 = token0;
    address _token1 = token1;
    require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;);
    if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
    if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
    if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
    balance0 = IERC20(_token0).balanceOf(address(this));
    balance1 = IERC20(_token1).balanceOf(address(this));
    &#125;
    uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
    require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;);
    &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors
    uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
    uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
    require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;);
    &#125;

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
&#125;</code></pre>

<h2 id="价格预言机"><a href="#价格预言机" class="headerlink" title="价格预言机"></a>价格预言机</h2><p>Uniswap V2使用的预言机是TWAP（Time-Weighted Average Price）时间加权平均价格。与chainlink获取的是多家交易所的加权价格不同，TWAP的数据来源于Uniswap自身交易数据，价格的计算都是在执行的，属于链上预言机。</p>
<p>在V2的Pair合约中，会存储两个状态变量：</p>
<pre><code class="highlight solidity">uint public price0CumulativeLast;
uint public price1CumulativeLast;</code></pre>

<p>在Pair合约_update函数中会更新这两个状态变量的值：</p>
<pre><code class="highlight solidity">// update reserves and, on the first call per block, price accumulators
function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;
    require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;);
    uint32 blockTimestamp = uint32(block.timestamp % 2**32);
    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
    if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;
        // * never overflows, and + overflow is desired
        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
    &#125;
    reserve0 = uint112(balance0);
    reserve1 = uint112(balance1);
    blockTimestampLast = blockTimestamp;
    emit Sync(reserve0, reserve1);
&#125;</code></pre>

<p>price0CumulativeLast和price1CumulativeLast分别记录token0和token1的累计价格。这里的累计价格就是整个Pair合约中，每秒价格的累加。</p>
<p>分析_update函数:</p>
<ul>
<li>1、首先获取区块时间戳，转化为uint32;</li>
<li>2、区块时间戳减去上一轮的区块时间戳，得到时间周期timeElapsed；</li>
<li>3、时间周期要大于0，才去更新price0CumulativeLast和price1CumulativeLast；</li>
<li>4、这边_reserve0、_reserve1是上一个区块后的Pair合约池中2种Token的储备量，balance0和balance1是当前交易后的2种Token的储备量；</li>
<li>5、累计价格算的就是上一个区块结束后的价格；</li>
<li>6、token0累计价格计算是token1储备量&#x2F;token0储备量*时间周期，在累加；</li>
<li>7、token1累计价格计算是token0储备量&#x2F;token1储备量*时间周期，在累加；</li>
<li>8、算好会更新token0和token1的储备量以及时间戳；</li>
</ul>
<h2 id="闪电贷原理"><a href="#闪电贷原理" class="headerlink" title="闪电贷原理"></a>闪电贷原理</h2><p>闪电贷说明确点就是在一笔交易中完成借款还款，中间可能会有个套利，就是借款—套利—还款，在同一笔交易中完成。</p>
<p>Uniswap V2支持闪电贷交易，这里直接从源码来分析，并实现一个demo。</p>
<p>Pair合约的swap函数源码如下：</p>
<pre><code class="highlight solidity">// this low-level function should be called from a contract which performs important safety checks
function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;
    require(amount0Out &gt; 0 || amount1Out &gt; 0, &#x27;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&#x27;);
    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
    require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY&#x27;);

    uint balance0;
    uint balance1;
    &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 &amp;&amp; to != _token1, &#x27;UniswapV2: INVALID_TO&#x27;);
        // （闪电贷）下面2行发送Token给to地址
        if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
        // 调用to地址的回调函数uniswapV2Call
        if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));
    &#125;
    uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
    uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
    require(amount0In &gt; 0 || amount1In &gt; 0, &#x27;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&#x27;);
    &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        // x*y=k 检查闪电贷是否还款成功，不成功会回滚交易
        require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), &#x27;UniswapV2: K&#x27;);
    &#125;

    _update(balance0, balance1, _reserve0, _reserve1);
    emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
&#125;</code></pre>

<p>闪电贷demo：</p>
<pre><code class="highlight solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import &#123;IERC20&#125; from &quot;./interfaces/IERC20.sol&quot;;
import &#123;IUniswapV2Factory&#125; from &quot;./interfaces/IUniswapV2Factory.sol&quot;;
import &#123;IUniswapV2Pair&#125; from &quot;./interfaces/IUniswapV2Pair.sol&quot;;
import &#123;IUniswapV2Callee&#125; from &quot;./interfaces/IUniswapV2Callee.sol&quot;;

contract UniswapV2Flashload  &#123;
    address private constant UNISWAP_V2_FACTORY =
    0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;

    address private constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    IUniswapV2Factory private constant factory = IUniswapV2Factory(UNISWAP_V2_FACTORY);

    IERC20 private constant weth = IERC20(WETH);

    IUniswapV2Pair private immutable pair;

    constructor() &#123;
        pair = IUniswapV2Pair(factory.getPair(DAI, WETH));
    &#125;

    // 闪电贷函数
    function flashloan(uint wethAmount) external &#123;
        // calldata长度大于1才能触发闪电贷回调函数
        bytes memory data = abi.encode(WETH, wethAmount);

        // amount0Out是要借的DAI, amount1Out是要借的WETH
        pair.swap(0, wethAmount, address(this), data);
    &#125;

    // 闪电贷回调函数，只能被 DAI/WETH pair 合约调用
    function uniswapV2Call(
        address sender,
        uint amount0,
        uint amount1,
        bytes calldata data
    ) external &#123;
        // 确认调用的是 DAI/WETH pair 合约
        address token0 = IUniswapV2Pair(msg.sender).token0(); // 获取token0地址
        address token1 = IUniswapV2Pair(msg.sender).token1(); // 获取token1地址
        assert(msg.sender == factory.getPair(token0, token1)); // ensure that msg.sender is a V2 pair

        // 解码calldata
        (address tokenBorrow, uint256 wethAmount) = abi.decode(data, (address, uint256));

        // flashloan 逻辑，这里省略
        require(tokenBorrow == WETH, &quot;token borrow != WETH&quot;);

        uint fee = (amount1 * 3) / 997 + 1;
        uint amountToRepay = amount1 + fee;

        // 归还闪电贷
        weth.transfer(address(pair), amountToRepay);
    &#125;
&#125;</code></pre>

<p>测试合约:</p>
<pre><code class="highlight solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import &quot;forge-std/Test.sol&quot;;
import &#123;UniswapV2Flashload&#125; from &quot;../src/UniswapV2Flashload.sol&quot;;
import &#123;IWETH&#125; from &quot;../src/interfaces/IWETH.sol&quot;;

address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

contract UniswapV2FlashloanTest is Test &#123;
    IWETH private weth = IWETH(WETH);

    UniswapV2Flashload private flashloan;

    function setUp() public &#123;
        flashloan = new UniswapV2Flashload();
    &#125;

    function testFlashloan() public &#123;
        // 换weth，并转入flashloan合约，用做手续费
        weth.deposit&#123;value: 1e18&#125;();
        weth.transfer(address(flashloan), 1e18);
        // 闪电贷借贷金额
        uint amountToBorrow = 100 * 1e18;
        flashloan.flashloan(amountToBorrow);
    &#125;

    // 手续费不足，会revert
    function testFlashloanFail() public &#123;
        // 换weth，并转入flashloan合约，用做手续费
        weth.deposit&#123;value: 1e18&#125;();
        weth.transfer(address(flashloan), 3e17);
        // 闪电贷借贷金额
        uint amountToBorrow = 100 * 1e18;
        // 手续费不足
        vm.expectRevert();
        flashloan.flashloan(amountToBorrow);
    &#125;
&#125;</code></pre></div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXX"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-XXXXXXXXX');</script></html>